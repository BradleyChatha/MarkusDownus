<p>@date-created 31-10-2019@
@date-updated 07-02-2020@
@title Serialising enums and classes@
@seo-tag serialise-enum-class@</p><p>
*Side note: In true D fashion, https://run.dlang.io is broken with no sign of it being fixed (in terms of creating links),
so from this point on I'll be using https://godbolt.org*</p><p>
In this post we'll cover how to serialise classes and enums, both of which have certain considerations to go over.</p><p></p><h2>Serialising enums</h2><p>
The first thing to consider with enums is whether to serialise them via their names
(e.g. <code>PersonType.Student</code> would become "Student"), or to serialise them
via their values.</p><p>
There are pros and cons to both, mostly revolving around enums that are used as bit flags,
but for now we're going to serialise them by names and later on provide a way to use either
names or values.</p><p>
We're going to need an enum to work with so let's create a <code>PersonType</code> enum
for our <code>Person</code> struct from our <a href="https://run.dlang.io/is/nCESzP)">previous code</a></p><p></p><pre><code>enum PersonType
{
    Unknown,
    Student,
    Staff
}

struct Person
{
    string name;
    int age;
    PersonType type;
}
</code></pre><p></p><h3>The issue with enums</h3><p>
There is one fairly important yet easy to solve issue with enums - they count as both an enum *and* their value type.</p><p>
For example, take our newly made <code>PersonType</code> enum. It is just a
bog standard enum where the value type is an <code>int</code> (by default).</p><p>
The <code>PersonType</code> enum, due to having a value type of <code>int</code>, will actually
**pass** a check such as <code>is(PersonType == int)</code> and <code>isNumeric!PersonType</code>.
Needless to say this is a bit of a roadblock due to our decision to serialise by name instead of value.</p><p>
Fortunately, this issue is actually super easy to work around. Via <code>is(T == enum)</code> we can create
code that works/doesn't work specifically for enums.</p><p></p><h3>Upgrading our serialise function</h3><p>
For reference, here's the shortened code for the serialise function:</p><p></p><pre><code>enum isPrimitiveType(T) = isNumeric!T || is(T == bool) || is(T == string);

JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == struct))
    { /* omitted for brevity */ }
    else
    { /* omitted for brevity */ }
}
</code></pre><p>
There are two options for us to take here:</p><p></p><ul><li><p>Modify <code>isPrimitiveType</code> so that it ignores enums, then handle enums later on in the function.</p></li></ul><p></p><ul><li><p>Handle enums inside the function **before** handling primitive types, so enums have a higher 'priority'.</p></li></ul><p>
We will in fact be doing both: option #1 for the <code>serialise</code> function, and then option #2 for the
<code>deserialise</code> function. This is to demonstrate both options.</p><p>
To start, we can use <code>!is(T == enum)</code> with <code>isPrimitiveType</code> so that it will ignore enums:</p><p></p><pre><code>// https://godbolt.org/z/_edV5X
enum isPrimitiveType(T) = !is(T == enum) && (isNumeric!T || is(T == bool) || is(T == string));    
</code></pre><p>
Next we need to add a <code>static if</code> so we can handle enums, and then turn the enum
value into its name with the help of the ever-so-useful std.conv#to function:</p><p></p><pre><code>JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == enum))
    {
        return JSONValue(value.to!string()); // PersonType.Student -> "Student", PersonType.Staff -> "Staff", etc.
    }
    else static if(is(T == struct))
    { /* omitted for brevity */ }
    else
    { /* omitted for brevity */ }
}    
</code></pre><p>
Note that if you do something weird such as <code>cast(PersonType)400</code>, then
<code>std.conv.to</code> will actually return <code>"cast(PersonType)400"</code>, which
will cause errors down the line.</p><p></p><h3>Upgrading our deserialise function</h3><p>
For reference, here's the shortened code for the deserialise function:</p><p></p><pre><code>T deserialise(T)(JSONValue json)
{
    static if(is(T == string))
    { /* omitted for brevity */ }
    else static if(is(T == bool))
    { /**/ }
    else static if(isFloatingPoint!T)
    { /**/ }   
    else static if(isSigned!T)
    { /**/ }
    else static if(isUnsigned!T)
    { /**/ }
    else static if(is(T == struct))
    { /**/ }
    else
    { /**/ }
}
</code></pre><p>
As I mentioned before, the <code>deserialise</code> function is going to handle
enums before any other type, so that the enum path takes priority over the others.</p><p>
Yet again, our lord and savior std.conv#to comes to our rescue as it can convert a string into an enum
as long as the string has the same name as one of the enum values:</p><p></p><pre><code>T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    {
        // "Student" -> PersonType.Student, etc.
        return json.str.to!T();
    }
    else static if(is(T == string))
    { /* omitted for brevity */ }
    else static if(is(T == bool))
    { /**/ }
    else static if(isFloatingPoint!T)
    { /**/ }   
    else static if(isSigned!T)
    { /**/ }
    else static if(isUnsigned!T)
    { /**/ }
    else static if(is(T == struct))
    { /**/ }
    else
    { /**/ }
}     
</code></pre><p>
Finally, as usual, we'll give things a quick test:</p><p></p><pre><code>// https://godbolt.org/z/f4xTyB
void main()
{
    import std.stdio : writeln;

    auto json = serialise(PersonType.Student);
    writeln(json);
    writeln(json.deserialise!PersonType());

    json = serialise(Person("Bradley", 20, PersonType.Student));
    writeln(json);
    writeln(json.deserialise!Person());

    /*
        Output:
            "Student"
            Student
            {"age":20,"name":"Bradley","type":"Student"}
            Person("Bradley", 20, Student)
    */
}
</code></pre><p></p><h2>Serialising classes</h2><p>
Serialising classes is where a lot of the more important decisions come into play, because
structs and classes are very different from one another.</p><p>
For example, while we *could* just treat classes like they're structs, that will only support
a very tiny amount of classes because:</p><p></p><ul><li><p>Classes can be null.</p></li></ul><p></p><ul><li><p>Classes may not have a reliable way to construct them (more on that later in the post).</p></li></ul><p></p><ul><li><p>Classes tend to not expose variables directly, but via getters, setters, and other functions.</p></li></ul><p></p><ul><li><p>And many other reasons...</p></li></ul><p>
This post will provide a way to handle some of these issues, but in a real project you may
need to fine tune how the serialiser works for your own needs as my solutions are going to be
relatively basic and therefore, not as robust as they could be.</p><p></p><h3>Treating classes as structs</h3><p>
Before we can start taking on some of the other issues we need to treat the most
basic case of simply being able to serialise and deserialise a class' public variables,
and then build off of that.</p><p>
For now we'll assume that all classes passed to the serialise function are not-null.
So for serialisation we can very simply just modify the <code>static if</code> that checks
for a struct, and extend it to also check for a class:</p><p></p><pre><code>JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == enum))
    { /**/ }
    else static if(is(T == struct) || is(T == class)) // <-----
    { /**/ }
    else
    { /**/ }
}   
</code></pre><p>
This will work for extremely simple classes, e.g. if you were to change <code>Person</code>
to a class it should be able to serialise a non-null instance of it perfectly fine.</p><p>
For the deserialise function our biggest hurdle is constructing a new instance of the class
so we can populate its fields. For now, our code will just assume that there is a default constructor
(e.g. <code>new MyClass()</code> works). Also keep in mind that <code>static if</code> does not create a scope:</p><p></p><pre><code>T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.
    {
        static if(is(T == class))
        {
            T toReturn = new T();
        }
        else
        {
            T toReturn; // Classes default to `null`, so we can't just reuse this line with them.
        }

        static foreach(member; T.tupleof)
        {{
            /**/
        }}

        return toReturn;
    }
    else
    { /**/ }
}
</code></pre><p>
As a quick example, change/copy <code>Person</code> to a class, and then we can
test if it works:</p><p></p><pre><code>// https://godbolt.org/z/EhHVdN
void main()
{
    import std.stdio : writeln, writefln;

    // The compiler doesn't generate a helper constructor like with structs,
    // so we'll do things like this for now.
    auto p = new Person();
    p.name = "Bradley";
    p.age = 20;
    p.type = PersonType.Student;

    auto json = p.serialise();
    writeln(json);

    // writeln can't automatically format a class like with structs.
    // So either override the `toString` function in a class, or just manually write out the fields.
    writefln("Person(%s, %s, %s)", p.name, p.age, p.type);

    /*
        Output:
            {"age":20,"name":"Bradley","type":"Student"}
            Person(Bradley, 20, Student)
    */
}
</code></pre><p></p><h3>Handling 'classes can be null'</h3><p>
Realistically, being able to handle null classes is a mandatory requirement, so
let's get that out of the way quickly.</p><p>
For serialising we can check if the class is null, and if it is then we can return a <code>JSONValue(null)</code>:</p><p></p><pre><code>JSONValue serialise(T)(T value)
{    
    static if(isPrimitiveType!T)
    { /* omitted for brevity */ }
    else static if(is(T == enum))
    { /**/ }
    else static if(is(T == struct) || is(T == class))
    {
        JSONValue toReturn;

        static if(is(T == class))
        {
            if(value is null)
            {
                return JSONValue(null);
            }
        }

        static foreach(member; T.tupleof)
        {{
            /**/
        }}

        return toReturn;
    }
    else
    { /**/ }
}
</code></pre><p>
Now if we were to pass a null class instance to the <code>serialise</code> function
it would output a <code>null</code> in JSON.</p><p>
For our <code>deserialise</code> function it's a very similar process - check if
the given JSON value is null, and if it is then return null:</p><p></p><pre><code>T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class)) // Remember to check for a class here as well.
    {
        static if(is(T == class))
        {
            if(json.type == JSONType.null_)
                return null;

            T toReturn = new T();
        }
        else
        {
            T toReturn;
        }

        /**/

        return toReturn;
    }
    else
    { /**/ }
}
</code></pre><p>
Very simple and very easy to handle, unlike the can of worms we're about to open regarding
construction of a class.</p><p>
But before we fall into despair over constructing classes, here's a quick test of the null
handling (change <code>Person</code> to a class):</p><p></p><pre><code>// https://godbolt.org/z/Q8pU7v
void main()
{
    import std.stdio : writeln;

    Person p = null;
    auto json = p.serialise();

    writeln(json);
    writeln(json.deserialise!Person());

    /*
        Output:
            null
            null
    */
}
</code></pre><p></p><h3>Handling 'classes may not have a reliable way to construct them' with __traits(compiles)</h3><p>
Currently, we use the code <code>new T()</code> to construct a new instance of a class.
This will only work if the class has either no constructors, or a default constructor.</p><p>
Again, realistically, classes are very likely to have parameterised constructors and are likely
incapable of supporting a default constructor.</p><p>
Just as a note, this only applies to deserialisation as serialising does not require
the construction of objects (well, unless you want it to).</p><p>
There are many ways you may want to handle this, such as using std.traits#Parameters
to check and recognise constructors with certain parameter patterns, having
a pre-defined list of constructor parameters that you support, or just
not allowing classes that do not contain a default constructor.</p><p>
In our case we're going to disallow the use of classes that do not contain a default
constructor. Fret not though, as we will be exploring one potential workaround soon.</p><p>
But for now we're going to be creating ourselves a helper template called <code>HasDefaultCtor</code>,
and we'll use that in our <code>deserialise</code> function to check if it returns <code>false</code>.</p><p>
One way we can do this is to check if the exact code of <code>new T()</code> can compile,
which we can achieve via another magical form of <code>__traits()</code> called
<a href="https://dlang.org/spec/traits.html#compiles)">__traits(compiles)</a></p><p>
By passing in some code as a parameter the compiler will determine if the code will
compile or not, and return a <code>bool</code> as the result.</p><p>
Please note that there is a certain annoyance to <code>__traits(compiles)</code> when the code
you're checking contains a template function, but such quirk is beyond this quick explanation of it.</p><p>
Anyway, by telling the compiler to check if <code>new T()</code> works for a given type
we can effectively check if the type has a default constructor, and then from there
we can use a <code>static assert</code> to display a message to the user:</p><p></p><pre><code>enum HasDefaultCtor(T) = __traits(compiles, new T());

T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        {
            static assert(HasDefaultCtor!T, "The class `" ~ T.stringof ~ "` requires a default constructor.");

            /**/
        }
        else
        {
        /	**/
        }

        /**/

        return toReturn;
    }
    else
    { /**/ }
}
</code></pre><p>
Here is an example of the error message:</p><p></p><pre><code>// https://godbolt.org/z/NSwveB

class NoDefaultCtor
{
    this(string str){}
}

void main()
{
    deserialise!NoDefaultCtor(JSONValue());

    /*
        Output:
            .\temp.d(27): Error: static assert:  "The class `NoDefaultCtor` requires a default constructor."
            .\temp.d(10):        instantiated from here: `deserialise!(NoDefaultCtor)`
    */
}
</code></pre><p>
This isn't overly ideal for many reasons but thankfully as we explore the workaround
we'll implement something that handles this issue to a somewhat reasonable degree.</p><p></p><h3>Workaround for the constructor issue, and the fact classes tend to not expose variables directly</h3><p>
I'll be brief. I've already gone over the constructor issue; and
because classes usually don't expose variables directly our current behaviour won't work for most
of them.</p><p>
Regarding the latter issue, there are several ways to handle the issue ranging from directly
inspecting the names of functions for keywords (e.g. starting with "get" or "set"), looking for
getters/setters that use the <code>@property</code> attribute, and any other ways suitable
for your use cases.</p><p>
The solution I will be going for is to add support for classes and structs to provide a static
<code>deserialise</code> function. This will serve as a workaround for the constructor issue as this
is essentially just a special constructor, and will also outsource the task of handling deserialisation
to the class itself, which *technically* handles the issue of classes not generally exposing variables.</p><p>
A downside of course is that there's more code to be written for classes to support
deserialisation, and therefore more technical debt over the long term.</p><p>
While you could also just specifically check for a constructor that takes a <code>JSONValue</code>,
I prefer to create specific functions for things like this as I don't like
that it'll limit classes from providing a <code>this(JSONValue)</code> constructor for other
purposes.</p><p>
The first thing we'll do is create another helper template (similar to <code>HasDefaultCtor</code>)
that will check for the special <code>deserialise</code> function.</p><p>
This template needs to check for:</p><p></p><ul><li><p>A static function called <code>deserialise</code>.</p></li></ul><p></p><ul><li><p>The function's return value is the same/compatible type as the class.</p></li></ul><p></p><ul><li><p>The function takes a <code>JSONValue</code> as the first parameter.</p></li></ul><p>
There are a few ways to do this, however we'll be using the trusty <code>__traits(compiles)</code> again:</p><p></p><pre><code>enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    
</code></pre><p>
Notice that the code we're checking is now inside brackets, since we're doing more
than a basic function call.</p><p>
We're using <code>T.deserialise</code> to specifically check for a static function
(or anything that has the same syntax as a static function); we assign the return value
to a <code>T obj</code> to check that the return value is compatible with whatever <code>T</code> is;
then finally we also check that a <code>JSONValue</code> can be passed as the first parameter.</p><p>
Next, in the <code>deserialise</code> function, we want to update the <code>static assert</code>
that requires classes to have a default constructor to check if the class has either
a default constructor, or a static deserialise function.</p><p>
We also need to hide the <code>T toReturn = new T()</code> line behind
the <code>HasDefaultCtor</code> check:</p><p></p><pre><code>enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    

T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        {
            static assert(HasDefaultCtor!T || HasStaticDeserialiseFunc!T, 
                "The class `" ~ T.stringof ~ "` requires a default constructor or a function matching "
                ~"`static " ~ T.stringof ~ " deserialise(JSONValue)`"
            ); 
            // e.g. "The class Person requires a default constructor or a function matching `static Person deserialise(JSONValue)`"

            /**/

            static if(HasDefaultCtor!T)
            {
                T toReturn = new T();
            }
        }
        /**/

        return toReturn;
    }
    else
    { /**/ }
}
</code></pre><p>
Now, if the class has a static deserialise function then we want to use that function
for deserialisation instead of our other logic. We still want to handle null std.json#JSONValue:JSONValues,
and we want to disable our other logic as we won't need it due to another issue of having
code exist beyond a <code>return</code> statement.</p><p>
To do this we just need to tactically employ <code>static if</code>:</p><p></p><pre><code>enum HasStaticDeserialiseFunc(T) = __traits(compiles, { T obj = T.deserialise(JSONValue()); });    

T deserialise(T)(JSONValue json)
{
    static if(is(T == enum))
    { /* omitted for brevity */ }
    /**/
    else static if(is(T == struct) || is(T == class))
    {
        static if(is(T == class))
        { /* null is still handled here */ }
        else
        { /**/ }

        static if(HasStaticDeserialiseFunc!T)
        {
            return T.deserialise(json);
        }
        else // If we don't disable this other code, then we'll get a "statement not reachable" error.
        {
            static foreach(/**/)
            {{
                /**/
            }}
            return toReturn;
        }
    }
    else
    { /**/ }
}
</code></pre><p>
To finish off, let's give it a test:</p><p></p><pre><code>// https://godbolt.org/z/Xbann8

class Person
{
    private
    {
        string name;
        int age;
        PersonType type;
    }

    // No default ctor.
    this(string name, int age, PersonType type)
    {
        this.name = name;
        this.age = age;
        this.type = type;
    }

    static Person deserialise(JSONValue value)
    {
        // Classes having to implement this logic themselves is a neccessary burden if you
        // were to go this route... or is it *wink* (this is a topic for a future post)
        return new Person(
            value["name"].deserialise!string(),
            value["age"].deserialise!int(),
            value["type"].deserialise!PersonType()
        );
    }

    // So that writeln can show us something useful.
    override string toString()
    {
        import std.format : format;

        return format("Person(%s, %s, %s)", this.name, this.age, this.type);
    }
}

void main()
{
    import std.stdio : writeln;

    auto person = new Person("Bradley", 20, PersonType.Student);
    auto json = person.serialise();

    writeln(json);

    person = json.deserialise!Person();
    writeln(person);

    /*
        Output:
            {"age":20,"name":"Bradley","type":"Student"}
            Person(Bradley, 20, Student)
    */
}
</code></pre><p></p><h2>Conclusion</h2><p>
Our serialiser can now serialise enums by name and has some dodgey support for serialising
classes, meaning it's starting to shape up to be at least *kind of* useable. Maybe.
If you're desperate.</p><p>
The next thing we'll look into is to serialise arrays and associative arrays.</p><p></p><h2>Excercises</h2><p></p><h3>Add support for classes and structs to provide their own serialise function</h3><p>
This might be something I end up doing in a future post, but for now this is a
good excercise to practice using <code>__traits(compiles)</code>.</p><p>
Basically, allow classes and structs to provide a custom <code>serialise</code> function.</p><p>
For the test case to work, the serialise function must match the signature of: <code>JSONValue serialise()</code></p><p>
And here's the test case:</p><p></p><pre><code>struct VerySimpleTest
{
    string lalafell;

    JSONValue serialise()
    {
        JSONValue json;

        json["lalafell"] = this.lalafell;
        json["hidden_secret"] = "Don't be a lalafell please.";

        return json;
    }
}

void main()
{
    auto json = serialise(VerySimpleTest("Zuzu"));
    assert(json["lalafell"].str == "Zuzu");
    assert(json["hidden_secret"].str == "Don't be a lalafell please.");
}
</code></pre>